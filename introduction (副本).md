
# 前言
感谢r0ysue,送了我手机，白嫖的快感。
上一篇发了如何写一个hook框架，但是还是依赖于root权限，而在android平台，magisk就是root的代名词。所以开始了。。。。。

## 越狱概论


+ 软件安全的崛起

软件安全所要解决的问题提是什么: 防攻击、防代码泄露。

那么为什么会有软件安全的问题，因为软件运行平台不安全，而软件的载体是编译后的应用文件，不安全的平台导致了这些应用文件会被攻击者获得，因而产生了软件安全。

所以软件安全的崛起，本质还是因为，运行平台端的不安全。

为什么运行平台端不安全那，pc而言，本身不提供也不担任应用保护的角色。而移动端，有一定程度的保护，甚至我觉得，开始他们是想做起来的，但是后续发现，基本不可能，为什么，正是因为越狱。

目前软件保护做的最好的是ios，假如，ios手机系统无法越狱，你能拿到他的真正的编译程序吗？

加固混淆这些安全技术就是用来对抗静态分析的，符号执行、模拟执行、混合执行、动态运行，就是用来破解加固混淆的。

反调试、反反反调试，特征检测，可信任执行环境，就是用来对抗动态执行的。


+ root权限主要分为两类：
    + 有根root：就是在使用越狱之后，root权限一直存在，随用随取，重启不消失
    + 无根root：使用了越狱之后，获取了root权限，但是重启后会消失，重启后想要再使用root权限，需要再次使用越狱工具获取权限


+ 越狱方式：
    + 漏洞提权（系统级别）

        这一种比较普遍和通用，不仅仅是移动设备，pc设备也通用。能够提权的漏洞一般都是比较严重的品相较好的漏洞，一年也没几个，但是一般都有，例如ios，号称安全性比andorid高，但是从开始到现在，一直有漏洞，虽然最新版本的漏洞还没有更新出来，但是迟早会有，andriod也是一样。漏洞可能还分为硬件和软件漏洞，这种就不细说了，主要还是看严重程度。大部分漏洞提权，都只能获得无根root,ios听说以前有一些有根的root,这种很少。

    + 固件提权

        + 普通固件提权

        这种在理论上来说，是百分之百可能，但是利用的门槛比较高，要过很多的坑，开源的可能比闭源的好做，如果遇到闭源的，例如无法修改固件，不知道格式等等，android 由于是开源的，解锁的手机，可以直接通过magisk修改rom，然后刷进行，也可以寻找源码直接编译一个新的有root权限的固件刷进去，或者ios,目前研究不多，后续有时间了，这部分会补上。

        但是这种通过固件提权的方式，有个问题，就是有可能会被反击，也就是厂家内置了一些固件验证，必须要过了这些验证，才能正常启动，否则是不允许启动的。这就需要修改更多固件的信息，对固件足够了解。
        
        + 板载驱动提权（可能写的不是很严谨）
      
        这个我开始没打算写的，只听过，没见过。但是参加mosec 看见大神亲手演示。
        
        首先，要知道，有很多设备，是不提供刷写功能的，比如向android这种刷写系统的功能，华为，小米这些手机，都是需要申请解锁的，对了还有sony，很多年前sony就有这个功能，而且是网络锁，如果没有解开网络锁，就无法刷写系统。改了固件刷不进去，也没用。但是，在系统固件之上，还有一层程序，用于刷写镜像，管理板子是否解锁，板载驱动啥的，soc这些，芯片程序，这一部分可能也是有漏洞的，而你可以运用这部分漏洞，攻击他的保护程序，从而打到可以刷写固件的目的。去年的mosec就演示了这个。芯片那些程序是开源的，通过分析找到了漏洞，然后进行攻击。我还听说过闭源程序，直接通过硬件手段，将程序搞下来，然后用ida进行分析，寻找漏洞，或者寻找算法解锁的。
        
    
+ 安全性：

    越狱的人，基本已经很少考虑这个问题。

    目前ios越狱用的就是无根越狱，而android用的是magisk，就是修改固件越狱。就安全性而言，一般来说，固件越狱是比漏洞越狱更加安全。
    
    漏洞越狱，预示这你的手机存在root提权漏洞，不仅你可以提权，任何一个第三方app,都有和你一样的提权机会，从而获取root权限。
    
    而固件提权，只有手机主人才拥有固件提权的机会，只要管控好嵌入的root管理程序，保证root权限不外泄，就能保证安全问题。



## ios越狱 (研究中，后续会补上)

## android越狱
 android的越狱，我们一般都是来说android系统的越狱。


+ 1、根文件系统可以读写年代，并且没有selinux
	
	权限管控，只有DAC,没有mac，也就是说，只要获取了root权限，就可以拥有一切，而且，根文件系统可读写，就可以修改文件系统，进行永久root
	
	当时，根本不需要内核漏洞，只需要应用漏洞，提权到root,修改rom，就可以永久提权了。
	
+ 开启固件rom，加入selinux

  在这个时期，效果一般，selinux ，杜绝了应用层root权限泄露，但是rom固件的效果一般，当时的手机普遍能解锁，然后刷机，而且android当时自带一个recovery，配合当年很火的supersu，直接就能刷进去一个su权限，获取root。他的原理就是把根文件系统重新打包，再刷进去，覆盖以前的rom。

  

+ 固件验证(avb)、回滚保护、system as root、 ab分区(更新较快，没跟上)

  固件验证，Android Verified Boot(这个没仔细查，研究的时候已经是2.0了)，多了一个vbmeta.img分区，用于校验 boot.img system.img vendor.img 这些分区，确保不被篡改(可以解锁，关闭)。

  system as root，原来的就是将system.img变成根文件系统，原来都是boot.img里面的ramdisk 是根文件系统的

  回滚保护，直接修改system.img镜像，无效，数据在启动的时候如果有vbmeta验证，会将数据修正。

  ab分区，分区修改，反正就是将recovery 分区删掉了，要想使用twrp,没法刷写进recovery了，需要用fastboot 直接应道twrp镜像


### 漏洞攻防
selinux android 4.4 好像就有了，5.0强制开了，seandroid 就是那个动态权限申请，都是基于selinux策略。


+ 1、漏洞提权
    + 拥有root权限的应用

        adbd服务，是android对外的命令行接口，最初是有root权限的，用户调用shell接口的时候，会权限降级，返回一个shell用户，然后有人就分析adbd的代码，挖掘adbd的漏洞，或者说挖掘拥有root权限的应用的漏洞，来获取root权限。

    + 内核漏洞提权

        这个不用解释了把
    
+ 2、selinux

    linux下有两种权限管控，传统的DAC（直接访问控制)，和MAC（强制访问控制）安全机制(selinx)。
    关于selinux,我看了很多资料，很长时间没弄明白，所以在这里就我自己的理解详细写一下。

    + MAC和DAC

        + DAC

            是以用户为主体，比如，就像现实世界中的人，你运动，你学习，你考大学，你装修，把自己的房子烧了，没人管你的，你的这些行为，就是进程，而你烧房子，花钱，等等，就是操作文件，房子就是文件，钱，就是文件，你怎么操作，没人管你，因为他们是属于你的，你是主体。

        + MAC 

            mac以进程为主体，文件，属性为客体，就像现实世界中，以事件为主体，物质为客体，这种情况下，假如你要烧你的房子，假如假如你要花你的钱，在DAC中是允许的，但是在mac中，会首先判断你的行为事件，比如你的行为事件是装修，是需要对房子进行操作的，但是你的操作确是烧房子，拆房子，就会被禁止，比如你要吃饭，是要花钱的，但是你的操作是花钱买法拉利了，这也是没有权限的。粒度为进程(有安全上下文标签)，管控行为，为读写，执行，等等，被执行者(文件)贴上标签，进程操作被文件的时候，通过进程和文件的标签判断，是否可以操作。

    selinux,是在mac基础上进行的加强和扩展

    + selinux 工作原理

        + 在编译的时候，确定了大致的安全策略，尤其一些比较重要，权限高的文件。这些安全策略会将这些文件管理的死死的，不会给予他们任何多余的权限

        + 全文件加标签，会将每一个文件都加上安全上下文的标签，彻彻底底的管控

        + 主要工作点是内核模块，在内核各个操作点，添加钩子，当操作发生的时候，会首先通过安全策略进行判断。(只要钩子写的全，就不可能绕过去)

	+ selinux 对于漏洞的防御
    
        selinux能防御应用层的root权限漏洞，对于内核层的root权限漏洞，存在直接从内核关闭selinux的可能。但是如果无法关闭selinux，root权限将无法外泄，因为selinux权限的策略对于root用户、权限的非root用户访问默认是禁止的。
    
        对于selinux 而言，是不是root，没有任何区别，root这个概念是DAC所提供的的用户概念，而selinux是策略控制的，不会因为，你是root用户，就不对你进行策略管控
    
        root用户在DAC权限来说是有关闭selinux的权限的(android上，别的linux没搞过，不清楚)，但是如果selinux如果打开了，你就要拥有关闭selinux权限的MAC策略权限。
    
        内核漏洞如果无法直接从内核层面关闭selinux，那么即使获取了root，也是无法绕过selinux策略的，跟用户层的root提权漏洞会面临一样的结果。
        
        


### magisk和固件
聊android越狱，不能不聊magisk，magisk的工程现在已经不小了，我们只讲一下我知道的大致原理和应用到的相关技术。

+ 修补内核镜像boot.img
解析boot.img ,分为kernel 和ramdisk,kernel 是内核，ramdisk 是一个文件系统，在非system as root 系统上，ramdisk位于根文件系统，在system as root 系统上，内核是不加载ramdisk的，magisk 会修改掉ramdisk 的init 程序，并在文件系统中，加入magisk相关的文件和配置，这样内核启动完毕后，第一个进入的的位置就是magisk 替换掉的 init 程序，对于system as root系统，确实不会主动加载ramdisk，但是maigsk 修改了内核的启动文件系统的参数。这样，会主动加载ramdisk为根文件系统
  
    ![magisk_fix1](/home/chic/Pictures/magisk_fix1.png)
  
    ​				

+ avb验证

    这个我没有手工验证过，有相关资料说会boot.img分区也会进行验证，而我们修改了这个分区，这个估计也有进行处理

    https://blog.csdn.net/pen_cil/article/details/102872394 可以参考下这个

+ 根文件系统还原

    高版本基本都是system as root系统，magisk 的init的程序会进行系统分区的挂载，比如将systen.img 挂载到自己定义的路径下，然后使用了mout bind技术，将挂载到自定义路径下的镜像还原到原来的路径。mout bind可以将目录合并，共用一个路径，如有有相同名字的文件，被合并者目录的文件会被隐藏，类似的技术还有overfs有人提过magisk可以用这个。
    
+ su文件和selinux
  
    一个可以获取root权限的su程序，但是在release 版本中，selinux并没有root权限外部访问的策略，selinux的策略文件是在编译的时候生成的，这一部分代码没有仔细分析，不过我估计是通过运行时selinx配置文件，我在magisk源码中发现了sepolicy-inject相关内容。想修改selinux策略，有两种方法方法，第一种，直接在编译的时候写好策略编译进rom，第二种，有个工具叫做sepolicy-inject，可以运行时修改策略文件 /sys/fs/selinux/policy，但是需要再次加载到内核中生效，magisk 环境提供了这个工具 ，并改名字叫做magiskpolicy。
    
    magisk 添加了一些selinux策略类型，让root权限可以进行外部访问。
    
+ magisk 隐藏root
  
  magisk 由于是替换根文件系统，所以，根目录的路径本身就不一样，而且，还有比较多的magisk本身的特征，检测工具就是通过检测这个特征来判断magisk 是否存在。
  
  后来magisk 单独写了一个模块专门针对这些特征，写了一个白名单来做处理，还有一个监控进程，修改app进程中magisk 的路径
  
  我看了近来的版本和changlog，这个白名单的方法已经消失了。目前来看关于文件挂载路径，最新magisk已经解决了这个问题，关于su文件这些依然通过特征反检测，或者通过selinux 策略进行判断，策略这种可能比较好，但是需要策略编写的很精准，具体到某一个app。
  

总的来说，magisk 相当不错的，坑填了非常多。
    

